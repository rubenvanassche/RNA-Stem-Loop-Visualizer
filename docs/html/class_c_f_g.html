<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>RNA Stem Loop Analyser</title>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
        <!--<link rel='stylesheet' type='text/css' href="http://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
    </head>
    <body>
        <div id="content">
        	<h1>RNA Stem Loop Analyser</h1>
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_c_f_g-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CFG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class representing a context free grammar.  
 <a href="class_c_f_g.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_c_f_g_8h_source.html">CFG.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CFG:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_c_f_g.png" usemap="#CFG_map" alt=""/>
  <map id="CFG_map" name="CFG_map">
<area href="class_c_n_f.html" title="The class CNF (Chomsky Normal Form), this is actually a CFG (Context Free Grammar) but with productio..." alt="CNF" shape="rect" coords="0,56,38,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74681f6f1a182d0e754e5db0e9545f5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a74681f6f1a182d0e754e5db0e9545f5b">CFG</a> (const std::set&lt; char &gt; &amp;terminals, const std::set&lt; char &gt; &amp;variables, const std::multimap&lt; char, SymbolString &gt; &amp;productions, const char &amp;startsymbol)</td></tr>
<tr class="memdesc:a74681f6f1a182d0e754e5db0e9545f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a74681f6f1a182d0e754e5db0e9545f5b">More...</a><br/></td></tr>
<tr class="separator:a74681f6f1a182d0e754e5db0e9545f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9e0feb406099038faea4c67ef31786"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a9e0feb406099038faea4c67ef31786"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a7a9e0feb406099038faea4c67ef31786">~CFG</a> ()</td></tr>
<tr class="memdesc:a7a9e0feb406099038faea4c67ef31786"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a7a9e0feb406099038faea4c67ef31786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391a7d2b5ef8145dff4c4b1d2c1dfe78"><td class="memItemLeft" align="right" valign="top">std::set&lt; SymbolString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a391a7d2b5ef8145dff4c4b1d2c1dfe78">bodies</a> (const char &amp;v) const </td></tr>
<tr class="memdesc:a391a7d2b5ef8145dff4c4b1d2c1dfe78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of bodies with the passed variable as head. For example if there are productions of the form A -&gt; "a" and A -&gt; "aA", then this will returns {"a", "aA"}.  <a href="#a391a7d2b5ef8145dff4c4b1d2c1dfe78">More...</a><br/></td></tr>
<tr class="separator:a391a7d2b5ef8145dff4c4b1d2c1dfe78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df6f5e5f972ede1a2f1eb210a5e33d6"><td class="memItemLeft" align="right" valign="top">std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a5df6f5e5f972ede1a2f1eb210a5e33d6">nullable</a> () const </td></tr>
<tr class="memdesc:a5df6f5e5f972ede1a2f1eb210a5e33d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the nullable variables.  <a href="#a5df6f5e5f972ede1a2f1eb210a5e33d6">More...</a><br/></td></tr>
<tr class="separator:a5df6f5e5f972ede1a2f1eb210a5e33d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac849b4a92eea2311a9626061b3e193b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#ac849b4a92eea2311a9626061b3e193b8">eleminateEpsilonProductions</a> ()</td></tr>
<tr class="memdesc:ac849b4a92eea2311a9626061b3e193b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eleminate epsilon productions. That is, eleminate productions of the form A -&gt; Îµ, but doing so that the <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a> still accepts the same language with epsilon (empty string excluded).  <a href="#ac849b4a92eea2311a9626061b3e193b8">More...</a><br/></td></tr>
<tr class="separator:ac849b4a92eea2311a9626061b3e193b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7d63958621b57a80d334827b9c6ceb"><td class="memItemLeft" align="right" valign="top">std::set&lt; std::pair&lt; char, char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#afe7d63958621b57a80d334827b9c6ceb">units</a> () const </td></tr>
<tr class="memdesc:afe7d63958621b57a80d334827b9c6ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the unit pairs of this <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>.  <a href="#afe7d63958621b57a80d334827b9c6ceb">More...</a><br/></td></tr>
<tr class="separator:afe7d63958621b57a80d334827b9c6ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4e75db20b0c39e0288c8f5146a8a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a61a4e75db20b0c39e0288c8f5146a8a6">eleminateUnitProductions</a> ()</td></tr>
<tr class="memdesc:a61a4e75db20b0c39e0288c8f5146a8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eleminate unit productions. That is, eleminate productions of the form A -&gt; B. But doing so that it does not affect the language of this <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>.  <a href="#a61a4e75db20b0c39e0288c8f5146a8a6">More...</a><br/></td></tr>
<tr class="separator:a61a4e75db20b0c39e0288c8f5146a8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b8b908c8af9211ebecab911d5cd5ea"><td class="memItemLeft" align="right" valign="top">std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#ac6b8b908c8af9211ebecab911d5cd5ea">generating</a> () const </td></tr>
<tr class="memdesc:ac6b8b908c8af9211ebecab911d5cd5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the generating symbols.  <a href="#ac6b8b908c8af9211ebecab911d5cd5ea">More...</a><br/></td></tr>
<tr class="separator:ac6b8b908c8af9211ebecab911d5cd5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fd806703a8f2187abbefaa72a5cb5c"><td class="memItemLeft" align="right" valign="top">std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a41fd806703a8f2187abbefaa72a5cb5c">reachable</a> () const </td></tr>
<tr class="memdesc:a41fd806703a8f2187abbefaa72a5cb5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the reachable symbols.  <a href="#a41fd806703a8f2187abbefaa72a5cb5c">More...</a><br/></td></tr>
<tr class="separator:a41fd806703a8f2187abbefaa72a5cb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b46d11fa9ce0670c1218d5231c20cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a08b46d11fa9ce0670c1218d5231c20cb">eleminateUselessSymbols</a> ()</td></tr>
<tr class="memdesc:a08b46d11fa9ce0670c1218d5231c20cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eleminate useless symbols. But doing so that is does not affect the language of this <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>.  <a href="#a08b46d11fa9ce0670c1218d5231c20cb">More...</a><br/></td></tr>
<tr class="separator:a08b46d11fa9ce0670c1218d5231c20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9999f6e214b05d9dfb0536b8b680e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#ab9999f6e214b05d9dfb0536b8b680e10">cleanUp</a> ()</td></tr>
<tr class="memdesc:ab9999f6e214b05d9dfb0536b8b680e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>, that is, eleminate epsilon productions, useless symbols and unit productions IN SAFE ORDER. This comes in handy for converting to <a class="el" href="class_c_n_f.html" title="The class CNF (Chomsky Normal Form), this is actually a CFG (Context Free Grammar) but with productio...">CNF</a> (Chomsky Normal Form). Also: removes all variables which don't have any production rules at all.  <a href="#ab9999f6e214b05d9dfb0536b8b680e10">More...</a><br/></td></tr>
<tr class="separator:ab9999f6e214b05d9dfb0536b8b680e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b4255577be81ace0b957bd05ffcc4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49b4255577be81ace0b957bd05ffcc4e"></a>
std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getTerminals</b> ()</td></tr>
<tr class="separator:a49b4255577be81ace0b957bd05ffcc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e29d2502f3189e7f7a9808d3871537"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a93e29d2502f3189e7f7a9808d3871537"></a>
std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getVariables</b> ()</td></tr>
<tr class="separator:a93e29d2502f3189e7f7a9808d3871537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3831e04435bec5137fbf8ec99342d53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3831e04435bec5137fbf8ec99342d53"></a>
std::multimap&lt; char, SymbolString &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getProductions</b> ()</td></tr>
<tr class="separator:aa3831e04435bec5137fbf8ec99342d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f285339723a8cbe79dcf3fc4eb1c551"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f285339723a8cbe79dcf3fc4eb1c551"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>getStartsymbol</b> ()</td></tr>
<tr class="separator:a7f285339723a8cbe79dcf3fc4eb1c551"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac016cd234680353c2335233b9e46cb47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac016cd234680353c2335233b9e46cb47"></a>
std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#ac016cd234680353c2335233b9e46cb47">fTerminals</a></td></tr>
<tr class="memdesc:ac016cd234680353c2335233b9e46cb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of terminal symbols. <br/></td></tr>
<tr class="separator:ac016cd234680353c2335233b9e46cb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2782ff517d0b17f6ae3853dae83ed144"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2782ff517d0b17f6ae3853dae83ed144"></a>
std::set&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#a2782ff517d0b17f6ae3853dae83ed144">fVariables</a></td></tr>
<tr class="memdesc:a2782ff517d0b17f6ae3853dae83ed144"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of variables. <br/></td></tr>
<tr class="separator:a2782ff517d0b17f6ae3853dae83ed144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acead5f2b9238ec9bbc56d9e1de16f44f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acead5f2b9238ec9bbc56d9e1de16f44f"></a>
std::multimap&lt; char, SymbolString &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_c_f_g.html#acead5f2b9238ec9bbc56d9e1de16f44f">fProductions</a></td></tr>
<tr class="memdesc:acead5f2b9238ec9bbc56d9e1de16f44f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of production rules. <br/></td></tr>
<tr class="separator:acead5f2b9238ec9bbc56d9e1de16f44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92bc7a21984ef4a6d6a86b2e2e1b53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acb92bc7a21984ef4a6d6a86b2e2e1b53"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><b>fStartSymbol</b></td></tr>
<tr class="separator:acb92bc7a21984ef4a6d6a86b2e2e1b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class representing a context free grammar. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a74681f6f1a182d0e754e5db0e9545f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CFG::CFG </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>terminals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::multimap&lt; char, SymbolString &gt; &amp;&#160;</td>
          <td class="paramname"><em>productions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>startsymbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">terminals</td><td>A set containing the terminals of the <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>. </td></tr>
    <tr><td class="paramname">variables</td><td>A set containing the variables of the <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>. </td></tr>
    <tr><td class="paramname">productions</td><td>A multimap that maps any symbol from the set of variables to a (possibly empty) SymbolString (which contains symbols from either the set of terminals or either the set of variables. </td></tr>
    <tr><td class="paramname">startsymbol</td><td>The startsymbol for the <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The set of variables and the set of terminals are disjoints.</li>
<li>The production rule is valid: the head consist of exactly one symbol that is in the set of the variables and the body must be empty or consisting of symbols that is either in the set of variables or in the set of terminals.</li>
<li>The starting symbol must be a member of the set of variables.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>One of the preconditions were not met. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a391a7d2b5ef8145dff4c4b1d2c1dfe78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; SymbolString &gt; CFG::bodies </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>v</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the set of bodies with the passed variable as head. For example if there are productions of the form A -&gt; "a" and A -&gt; "aA", then this will returns {"a", "aA"}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The variable representing the head of the production rules.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The set of SymbolString representing the body of the production rules whose head is the passed variable.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><ul>
<li>The passed variable must be in the set of the variables.</li>
</ul>
</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>The precondition were not satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9999f6e214b05d9dfb0536b8b680e10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CFG::cleanUp </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>, that is, eleminate epsilon productions, useless symbols and unit productions IN SAFE ORDER. This comes in handy for converting to <a class="el" href="class_c_n_f.html" title="The class CNF (Chomsky Normal Form), this is actually a CFG (Context Free Grammar) but with productio...">CNF</a> (Chomsky Normal Form). Also: removes all variables which don't have any production rules at all. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The production rules doesn't contain any nullable symbols. </dd>
<dd>
The production rules doesn't contain any useless symbols. </dd>
<dd>
The <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a> has only unit pairs of the form (A, A) for each A is a variable. </dd></dl>

</div>
</div>
<a class="anchor" id="ac849b4a92eea2311a9626061b3e193b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CFG::eleminateEpsilonProductions </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eleminate epsilon productions. That is, eleminate productions of the form A -&gt; Îµ, but doing so that the <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a> still accepts the same language with epsilon (empty string excluded). </p>
<dl class="section post"><dt>Postcondition</dt><dd>The production rules doesn't contain any nullable symbols. </dd></dl>

</div>
</div>
<a class="anchor" id="a61a4e75db20b0c39e0288c8f5146a8a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CFG::eleminateUnitProductions </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eleminate unit productions. That is, eleminate productions of the form A -&gt; B. But doing so that it does not affect the language of this <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>. </p>
<dl class="section note"><dt>Note</dt><dd>The algorithm only works if there is no cycle of unit productions. That is, unit pairs of the form A -&gt; B, B -&gt; C and C -&gt; A. If that's the case, an exception will be thrown.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When there are cyclic unit pairs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>The <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a> has only unit pairs of the form (A, A) for each A is a variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a08b46d11fa9ce0670c1218d5231c20cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CFG::eleminateUselessSymbols </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Eleminate useless symbols. But doing so that is does not affect the language of this <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The production rules doesn't contain any useless symbols. </dd>
<dd>
The <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a> still accepts the same language. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6b8b908c8af9211ebecab911d5cd5ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; char &gt; CFG::generating </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the generating symbols. </p>
<dl class="section return"><dt>Returns</dt><dd>The set of generating symbols. </dd></dl>

</div>
</div>
<a class="anchor" id="a5df6f5e5f972ede1a2f1eb210a5e33d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; char &gt; CFG::nullable </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the nullable variables. </p>
<dl class="section return"><dt>Returns</dt><dd>The set of all nullable variables. </dd></dl>

</div>
</div>
<a class="anchor" id="a41fd806703a8f2187abbefaa72a5cb5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; char &gt; CFG::reachable </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the reachable symbols. </p>
<dl class="section return"><dt>Returns</dt><dd>The set of all reachable symbols. </dd></dl>

</div>
</div>
<a class="anchor" id="afe7d63958621b57a80d334827b9c6ceb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; std::pair&lt; char, char &gt; &gt; CFG::units </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the unit pairs of this <a class="el" href="class_c_f_g.html" title="Class representing a context free grammar. ">CFG</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The set of all unit pairs.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>When there are cyclic unit pairs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_c_f_g_8h_source.html">CFG.h</a></li>
<li>src/CFG.cpp</li>
</ul>
</div><!-- contents -->
        </div>
        <div id="footer-container">
            <div id="footer">
                Copyright © Ruben Van Assche, Stijn Wouter, Jakob Struye, Pieter Lauwers &nbsp;::&nbsp;
                Theme by SFML(Laurent Gomila)
            </div>
        </div>
    </body>
</html>
